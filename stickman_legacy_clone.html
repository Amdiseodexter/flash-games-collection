<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Stickman Legacy — Small Prototype</title>
  <style>
    :root{--bg:#0f1724;--panel:#0b1220;--accent:#10b981;--muted:#94a3b8}
    body{margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:#e6eef6}
    header{padding:12px 18px;border-bottom:1px solid rgba(255,255,255,0.04);display:flex;align-items:center;gap:18px}
    h1{font-size:18px;margin:0}
    .hud{display:flex;gap:12px;align-items:center;margin-left:auto}
    .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
    button{background:#0b1220;color:white;padding:8px 10px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);cursor:pointer}
    main{display:flex;gap:12px;padding:12px}
    #gameWrap{background:#071025;border-radius:10px;flex:1;padding:10px}
    #game{background:#081226;display:block;border-radius:6px}
    #sidebar{width:300px}
    .stat{margin-bottom:8px}
    .btn-row{display:flex;gap:8px;flex-wrap:wrap}
    .small{padding:6px 8px;font-size:14px}
    .big{padding:10px 14px;font-size:16px}
    .note{font-size:12px;color:var(--muted)}
    footer{padding:12px;text-align:center;color:var(--muted);font-size:13px}
  </style>
</head>
<body>
<header>
  <h1>Stickman Legacy — Prototype</h1>
  <div class="hud">
    <div class="panel stat">Money: $<span id="money">200</span></div>
    <div class="panel stat">Your Statue HP: <span id="statueHP">1000</span></div>
    <div class="panel stat">Wave: <span id="wave">0</span></div>
  </div>
</header>
<main>
  <div id="gameWrap">
    <canvas id="game" width="900" height="500"></canvas>
    <div style="margin-top:8px;display:flex;gap:8px;align-items:center;justify-content:center">
      <button id="attackBtn" class="big">Attack</button>
      <button id="defendBtn" class="big">Defend</button>
      <button id="spawnEnemyBtn" class="big">Spawn Enemy (test)</button>
      <div class="note">Click gold rocks to pick up or spawn miners to auto-collect.</div>
    </div>
  </div>
  <aside id="sidebar">
    <div class="panel" style="margin-bottom:10px">
      <div style="font-weight:600;margin-bottom:6px">Build</div>
      <div class="btn-row">
        <button id="spawnStick" class="small">Spawn Stickman ($50)</button>
        <button id="spawnMiner" class="small">Spawn Miner ($80)</button>
        <button id="buildStatue" class="small">Repair Statue ($100)</button>
      </div>
    </div>

    <div class="panel" style="margin-bottom:10px">
      <div style="font-weight:600;margin-bottom:6px">Game Controls</div>
      <div class="btn-row">
        <button id="resetBtn" class="small">Reset</button>
        <button id="speedBtn" class="small">Toggle Speed</button>
      </div>
    </div>

    <div class="panel">
      <div style="font-weight:600;margin-bottom:6px">Info</div>
      <div class="note">Units auto-fight nearest enemy. Miners prefer gold. Enemies damage your statue on contact.</div>
    </div>
  </aside>
</main>
<footer>Prototype made for GitHub Pages. Tell me what to change next (balance, visuals, units).</footer>

<script>
// ====== Simple Stickman Legacy-like prototype ======
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const moneyEl = document.getElementById('money');
const statueHPel = document.getElementById('statueHP');
const waveEl = document.getElementById('wave');

let state = {
  money: 200,
  units: [], // player units
  enemies: [],
  gold: [],
  miners: [],
  wave: 0,
  statueHP: 1000,
  spawnRightX: canvas.width - 80,
  baseX: 80,
  speedMultiplier: 1,
  mode: 'defend' // 'attack' or 'defend'
};

// Utility
function rand(min,max){return Math.random()*(max-min)+min}
function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y)}

// Create some gold rocks
for(let i=0;i<5;i++){
  state.gold.push({x:rand(220,canvas.width-220), y:rand(80,canvas.height-80), amount: rand(50,200)|0});
}

// draw functions
function drawStick(ctx,x,y,scale=1,color='#fff'){
  ctx.save(); ctx.translate(x,y); ctx.scale(scale,scale); ctx.lineWidth = 2; ctx.strokeStyle = color; ctx.fillStyle = color;
  // head
  ctx.beginPath(); ctx.arc(0,-12,6,0,Math.PI*2); ctx.stroke();
  // body
  ctx.beginPath(); ctx.moveTo(0,-6); ctx.lineTo(0,10); ctx.stroke();
  // arms
  ctx.beginPath(); ctx.moveTo(-8,0); ctx.lineTo(8,0); ctx.stroke();
  // legs
  ctx.beginPath(); ctx.moveTo(0,10); ctx.lineTo(-8,20); ctx.moveTo(0,10); ctx.lineTo(8,20); ctx.stroke();
  ctx.restore();
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // ground
  ctx.fillStyle = '#07132a'; ctx.fillRect(0, canvas.height-60, canvas.width, 60);

  // draw statue (player) left
  ctx.fillStyle = '#6ee7b7';
  ctx.fillRect(40, canvas.height-160, 60, 100);
  ctx.fillStyle = '#05221a'; ctx.fillRect(40, canvas.height-170, 60, 10);
  ctx.fillStyle = 'rgba(255,255,255,0.04)'; ctx.fillRect(30, canvas.height-170, 80, 140);

  // draw statue (enemy) right
  ctx.fillStyle = '#fca5a5';
  ctx.fillRect(canvas.width-100, canvas.height-160, 60, 100);

  // draw gold
  for(const g of state.gold){
    ctx.save(); ctx.translate(g.x,g.y);
    ctx.fillStyle = '#d97706'; ctx.beginPath(); ctx.ellipse(0,0,16,12,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#fff'; ctx.font='10px Arial'; ctx.fillText('$'+g.amount, -12, 4);
    ctx.restore();
  }

  // draw units
  for(const u of state.units){ drawStick(ctx,u.x,u.y,1,u.teamColor); }
  for(const m of state.miners){ drawStick(ctx,m.x,m.y,0.9,m.teamColor); }
  for(const e of state.enemies){ drawStick(ctx,e.x,e.y,1,e.teamColor); }

  // UI overlays
  ctx.fillStyle='#fff'; ctx.font='12px Arial'; ctx.fillText('Your side', 50, 24);
  ctx.fillText('Enemy side', canvas.width-140, 24);
}

// basic unit creation
function spawnStickman(){
  if(state.money < 50) return; state.money -= 50; updateHUD();
  state.units.push({x:state.baseX + rand(-20,20), y: canvas.height-100, hp:100, dmg:10, speed:1.6, team:'player', teamColor:'#fff', target:null});
}
function spawnMiner(){
  if(state.money < 80) return; state.money -= 80; updateHUD();
  state.miners.push({x:state.baseX + rand(-20,20), y: canvas.height-100, hp:80, speed:1.2, team:'player', teamColor:'#facc15', carrying:0, target:null});
}

function spawnEnemy(){
  state.enemies.push({x:state.spawnRightX + rand(0,40), y: canvas.height-100, hp:80, dmg:6, speed:1.3, team:'enemy', teamColor:'#ff7b7b'});
}

// game logic: movement, targeting, combat
function step(dt){
  // miners: target closest gold or return to base if carrying
  for(const m of state.miners){
    if(m.carrying > 0){ // return to base
      let target = {x:state.baseX, y: canvas.height-100};
      moveTowards(m, target, m.speed * dt * state.speedMultiplier);
      if(Math.hypot(m.x-target.x,m.y-target.y) < 12){ state.money += m.carrying; m.carrying = 0; updateHUD(); }
      continue;
    }
    // find nearest gold
    if(state.gold.length > 0){
      let best = null; let bestd=99999;
      for(const g of state.gold){ let d = Math.hypot(m.x-g.x,m.y-g.y); if(d<bestd){bestd=d;best=g;} }
      if(best){ moveTowards(m, best, m.speed * dt * state.speedMultiplier); if(Math.hypot(m.x-best.x,m.y-best.y) < 18){ // collect
        let take = Math.min(20, best.amount|0);
        best.amount -= take; m.carrying += take;
        if(best.amount <= 0) state.gold.splice(state.gold.indexOf(best),1);
      }}
    } else { // no gold, idle near base
      moveTowards(m, {x:state.baseX + rand(-20,20), y: canvas.height-100}, m.speed * dt * state.speedMultiplier);
    }
  }

  // units: behavior depends on mode
  for(const u of state.units){
    // pick a target: nearest enemy
    let target = getNearest(u, state.enemies);
    if(state.mode === 'defend' && !target){ // stay near statue
      moveTowards(u, {x:state.baseX + rand(-40,40), y: canvas.height-100}, u.speed * dt * state.speedMultiplier);
    } else if(target){
      moveTowards(u, target, u.speed * dt * state.speedMultiplier);
      // if close, fight
      if(Math.hypot(u.x-target.x,u.y-target.y) < 18){
        target.hp -= u.dmg * dt * 0.4; // scaled by dt
        if(target.hp <= 0) state.enemies.splice(state.enemies.indexOf(target),1);
      }
    } else if(state.mode === 'attack'){ // move towards enemy statue
      moveTowards(u, {x:canvas.width-120,y:canvas.height-100}, u.speed * dt * state.speedMultiplier);
    }
  }

  // enemies: attack nearest player units or statue
  for(const e of state.enemies){
    let target = getNearest(e, state.units.concat(state.miners));
    if(target){ moveTowards(e, target, e.speed * dt * state.speedMultiplier);
      if(Math.hypot(e.x-target.x,e.y-target.y) < 18){ target.hp -= e.dmg * dt * 0.4; if(target.hp <= 0){ // remove
        const idx = state.units.indexOf(target); if(idx>=0) state.units.splice(idx,1);
        const idx2 = state.miners.indexOf(target); if(idx2>=0) state.miners.splice(idx2,1);
      }}
    } else { // no units: go for statue
      moveTowards(e, {x:60,y:canvas.height-100}, e.speed * dt * state.speedMultiplier);
      if(Math.hypot(e.x-60,e.y-(canvas.height-100))<22){ // damage statue
        state.statueHP -= e.dmg * dt * 0.6;
        if(state.statueHP <= 0){ state.statueHP = 0; } // lose condition not implemented further
      }
    }
  }

  // cleanup dead players (hp<=0)
  for(let i=state.units.length-1;i>=0;i--) if(state.units[i].hp <= 0) state.units.splice(i,1);
  for(let i=state.miners.length-1;i>=0;i--) if(state.miners[i].hp <= 0) state.miners.splice(i,1);

}

function moveTowards(obj, target, stepSize){
  let dx = target.x - obj.x; let dy = target.y - obj.y; let d = Math.hypot(dx,dy);
  if(d < 1) return;
  obj.x += (dx/d) * stepSize;
  obj.y += (dy/d) * stepSize;
}

function getNearest(source, list){ if(!list || list.length===0) return null; let best=list[0],bd=dist(source,list[0]); for(const t of list){ let d=dist(source,t); if(d<bd){bd=d;best=t}} return best; }

// mouse interaction to pick up gold
canvas.addEventListener('click', (e)=>{
  const rect = canvas.getBoundingClientRect(); const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
  for(let i=state.gold.length-1;i>=0;i--){ const g=state.gold[i]; if(Math.hypot(g.x-mx,g.y-my) < 22){ state.money += g.amount; state.gold.splice(i,1); updateHUD(); return; }}
});

function updateHUD(){ moneyEl.textContent = Math.max(0, Math.floor(state.money)); statueHPel.textContent = Math.max(0, Math.floor(state.statueHP)); waveEl.textContent = state.wave; }

// Buttons
document.getElementById('spawnStick').onclick = ()=>spawnStickman();
document.getElementById('spawnMiner').onclick = ()=>spawnMiner();
document.getElementById('attackBtn').onclick = ()=>{ state.mode='attack'; document.getElementById('attackBtn').disabled=true; document.getElementById('defendBtn').disabled=false; };
document.getElementById('defendBtn').onclick = ()=>{ state.mode='defend'; document.getElementById('defendBtn').disabled=true; document.getElementById('attackBtn').disabled=false; };
document.getElementById('spawnEnemyBtn').onclick = ()=>spawnEnemy();
document.getElementById('resetBtn').onclick = ()=>{ location.reload(); };

// initial button state
document.getElementById('defendBtn').disabled = true;

// wave/spawning system (enemies)
let waveTimer = 0;
function waveTick(dt){
  waveTimer += dt;
  if(waveTimer > 5){
    waveTimer = 0; state.wave++; updateHUD();
    // spawn a number of enemies scaled by wave
    let count = 2 + Math.floor(state.wave * 0.8);
    for(let i=0;i<count;i++){ setTimeout(()=>spawnEnemy(), i*400); }
    // also spawn some gold occasionally
    if(Math.random() < 0.7) state.gold.push({x:rand(220,canvas.width-220), y:rand(80,canvas.height-120), amount: 40 + ((state.wave|0)*10)});
  }
}

// simple economy: periodic interest
let incomeTimer = 0;
function incomeTick(dt){ incomeTimer += dt; if(incomeTimer > 3){ incomeTimer=0; state.money += Math.floor( state.miners.length * 5 ); updateHUD(); } }

// main loop
let last = performance.now();
function loop(now){
  let dt = (now - last)/16.666; // ~60fps unit
  last = now;
  // cap dt
  if(dt > 4) dt = 4;
  // update
  step(dt);
  waveTick(dt);
  incomeTick(dt);
  draw();
  requestAnimationFrame(loop);
}
updateHUD(); requestAnimationFrame(loop);

// Expose a few helpers so you can tweak from console
window.SL = state;
window.spawnEnemy = spawnEnemy;
</script>
</body>
</html>
